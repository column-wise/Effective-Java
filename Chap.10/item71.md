# item 71. 필요 없는 검사 예외 사용은 피하라

검사 예외를 싫어하는 자바 프로그래머가 많지만  
제대로 활용하면 API와 프로그램의 질을 높일 수 있다.

물론 과하게 사용하면 불편한 API가 된다...  
어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면, 이를 호출하는 코드는 catch 블록을 두어 예외를 잡거나 더 바깥으로 던져야 한다.

또한 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다....

## 검사 예외를 쓸 때 필요한 2가지 조건

1. API 사용자가 아무리 제대로 코드를 짜도 예외 상황을 피할 수 없다.
2. 예외가 발생했을 때 API 사용자가 뭔가 의미 있는 처리를 할 수 있다.

둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 게 좋다.

예를 들어

```java
} catch (TheCheckedException e) {
    throw new AssertionError(); // 절대 발생하지 않는다고 확신
}
```

or

```java
} catch (TheCheckedException e) {
    e.printStackTrace(); // 그냥 출력하고
    System.exit(1);       // 프로그램 종료
}
```

처럼 호출자가 예외를 받아도 별 의미 있는 처리를 하지 못한다면  
예외를 굳이 검사 예외로 만들 필요가 없다.

## 검사 예외 회피법

1. 적절한 결과 타입을 담은 옵셔널 반환

   실패한 경우에는 Optional.empty() 반환

   호출자는 isPresent() 등으로 예외 처리 없이 처리 가능  
    but 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
   (예외는 클래스 타입이나 메서드를 통해 추가 정보 전달 가능)

2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다

ex. 기존 검사 예외를 던지는 메서드

```java
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // 처리
}
```

-> 리팩토링

```java
if (obj.actionPermitted(args)) {
    obj.action(args); // 실패하면 런타임 예외
} else {
    // 실패 대응
}
```

이 리팩토링을 모든 상황에 적용할 수 없고, 리팩토링 이후 API가 더 아름답지는 않지만, 더 유연한 것은 확실하다.
